为什么我们会想到这个课题呢？
主要是因为Windows原有的访问控制体系存在一定的局限性。
首先，Windows系统只有自主访问控制，而这对于具有一定专业性的用户来说是远远不够的。其次，Windows的用户安全控制只有2-4层安全等级控制，控制粒度不够精密。同时，Windows的访问控制体系无法被远程管理，这对于企业等在应用的过程中也是不够方便的。
为何其他平台上的访问控制系统无法适用于Windows呢？
以Linux为例，Linux主要依靠SELinux作为其强制访问控制系统。而这套系统是针对用户的，这主要是因为Linux服务有详细的用户区分。
比如我们看到……
而相比之下，Windows的各种服务只有2-3个账户，而大部分服务器也只有少量的账户。
因此，无法针对账户配置安全策略。
(pass)
我们课题的一个创新点是以程序而非用户作为访问控制策略的主体。
Windows系统往往账户数量很少，但是以程序为主体之后，我们可以灵活地设置程序的策略，从而发挥上述安全模型的作用。
首先，我们将同一个程序的可执行文件归为程序组。
一些程序组拥有相似功能，其行为也是相似的，我们将这些程序组的归为程序角色。
比如IE和Chrome、Firefox作为同样的网络浏览器，其访问网络的行为也是相似的。用户可以对于同一组别设置相同的规则，从而大大简化配置工作。
(pass)
从而，一个主体进程，具有以下性质：程序角色、访问记录、执行用户的权限以及其他全系统策略等。根据这些性质，访问控制引擎得以制定访问控制策略。
我们课题的另一个创新点是将主体过去访问历史作为访问控制策略的参考对象，智能化地生成访问控制规则。
(pass)
我们这么做的原因主要有以下几点。
首先，利用主体访问历史可以有效地解决主体访问时的冲突。
在本系统中，主体并非用户而是进程。原有的BLP等安全模型，为用户而设计，对于程序来说比较死板。
而与此同时，Windows作为闭源操作系统，许多应用程序无法了解其内在调用机制。这增加了冲突的可能性。
考虑到系统的实用性，我们将原来的BLP模型的星特性，在一定范围内，修改为等级临时上调，结合询问用户和智能化判断来减少冲突。
在调试中，这一策略极大地加强了系统的可用性。
(pass)
同时，利用主体访问历史可以智能化地生成规则。
无论是应用程序还是恶意软件，其行为有很强的规律性。
我们利用主体访问历史，通过机器学习等相应的人工智能算法，对于用户的判断进行归纳，就可以智能地生成访问控制规则，从而完善原有的规则。
而且还可以结合历史在必要时向用户提供推荐的处理建议，从而有效地增强系统的有效性、实用性和友好性。
(pass)
对于访问控制的客体对象，主要是文件。由于Windows的特性，我们提高细粒度到注册表和其他系统配置文件等其他系统关键信息。
(pass)
以下就是我们的后台客户端界面。完善的C/S架构，使得管理员，可以方便地通过网络配置客户计算机的策略上。

PS:我觉得太长了。。。
望修改
